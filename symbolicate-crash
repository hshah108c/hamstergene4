#!/usr/bin/python
from __future__ import print_function

def symbolicate_crash_cmd(args):
    crash_lines = open(args.dotcrash, "r").readlines()

    import collections, os, os.path, re, subprocess, sys

    #
    # enumerate binary images in the crash
    binaries = {}
    BinaryInfo = collections.namedtuple('BinaryInfo', ["start_hex", "end_hex", "name", "uuid", "path"])
    i = 0
    while (i < len(crash_lines)) and not crash_lines[i].startswith("Binary Images:"):
        i += 1
    while (i < len(crash_lines)):
        i += 1
        rxm = re.search(r'''(0x[0-9a-fA-F]+) \s* - \s* (0x[0-9a-fA-F]+) \s+ \+?(\S+) .* <([0-9a-fA-F\-]+)> \s+ ([^\n\r\t]+)''', crash_lines[i], flags=re.X)
        if not rxm:
            break
        start_hex, end_hex, name, uuid, path = rxm.groups()
        info = BinaryInfo(start_hex=start_hex, end_hex=end_hex, name=name, uuid=uuid.upper(), path=path)
        binaries[name] = info

    #
    # enumerate dsyms
    dsyms = {}
    dirs = args.symdirs if args.symdirs else ["."]
    for dsymdir in dirs:
        for fn in os.listdir(dsymdir):
            if not fn.endswith(".dSYM"):
                continue
            path = os.path.join(dsymdir, fn)
            try:
                output = subprocess.check_output(["dwarfdump", "--uuid", path], universal_newlines=True)
                rxm = re.search(r'''UUID: \s+ ([0-9a-fA-F\-]+) \s+ \(\S+\) \s+ ([^\n\r\t]+)''', output, flags=re.X)
                uuid, binpath = rxm.groups()
                dsyms[uuid.upper()] = binpath
            except subprocess.CalledProcessError, ex:
                print("dwarfdump failed: {}".format(path), file=sys.stderr)
    assert dsyms, "no .dSYM files found in directories: {}".format(dirs)

    #
    # find lines with unresolved symbols and plan atos calls
    atos_calls = {}
    AtosAddress = collections.namedtuple("AtosAddress", ["hexaddr", "index", "needle"])
    failed_binaries = {}
    for i in range(len(crash_lines)):
        # example: 1   libguimodel.dylib                0x006ee72a 0x64d000 + 661290
        rxm = re.search(r'''^\d+ \s+ (\S+) \s+ (0x[0-9a-fA-F]+) \s+ (0x[^\n\r\t]+)''', crash_lines[i], flags=re.X)
        if rxm:
            name, hexaddr, needle = rxm.groups()
            if name in failed_binaries:
                continue
            if (name in binaries) and (binaries[name].uuid in dsyms):
                if name in atos_calls:
                    atos_addresses = atos_calls[name]
                else:
                    atos_addresses = []
                    atos_calls[name] = atos_addresses
                atos_addresses.append(AtosAddress(hexaddr=hexaddr, index=i, needle=needle))
            else:
                # Check if dsym is found, but uuids do not match.
                fn = os.path.basename(binaries[name].path)
                for dsympath in dsyms.values():
                    if os.path.basename(dsympath) == fn:
                        failed_binaries[name] = "binary and dSYM are from different builds ('{}' has different UUID from '{}')".format(binaries[name].path, dsympath)
                        break
                else:
                    # for-else is executed when `for` was not terminated by `break`
                    failed_binaries[name] = "no symbols found"

    #
    # make atos calls and substitute lines in the report
    replacements_made = False
    for name in atos_calls:
        load_hex = binaries[name].start_hex
        dwarf_path = dsyms[binaries[name].uuid]
        atos_addresses = atos_calls[name]
        hexes = [addr.hexaddr for addr in atos_addresses]
        try:
            inv_args = ["atos", "-l", load_hex, "-o", dwarf_path] + hexes
            output = subprocess.check_output(inv_args, universal_newlines=True)
        except subprocess.CalledProcessError, ex:
            failed_binaries[name] = "atos failed"
        output_lines = output.splitlines()
        if len(output_lines) < len(atos_addresses):
            failed_binaries[name] = "atos produced strange output (unknown version?)"
        else:
            for i in range(len(atos_addresses)):
                addr = atos_addresses[i]
                line = crash_lines[addr.index].replace(addr.needle, output_lines[i])
                if line != crash_lines[addr.index]:
                    crash_lines[addr.index] = line
                    replacements_made = True

    #
    # output the result
    if replacements_made or not failed_binaries:
        exit_code = 0
        if args.rewrite:
            open(args.dotcrash, "w").write("".join(crash_lines))
        else:
            for line in crash_lines:
                print(line, end="") # newlines are already there for the original file
    else:
        exit_code = 1

    #
    # print warnings
    for name in failed_binaries:
        print("{}: {}".format(name, failed_binaries[name]), file=sys.stderr)

    raise SystemExit(exit_code)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--symdirs", action="append", metavar="dsymdir", help="Directory with .dSYM bundles, may appear multiple times. If absent, the current working directory will be used.")
    parser.add_argument("-w", "--rewrite", action="store_true", help="Rewrite crash file inplace, instead of printing symbolicated result to stdout.")
    parser.add_argument("dotcrash", help="A crash file to symbolicate.")
    parser.add_argument("--version", action="version", version="%(prog)s 0.3")
    args = parser.parse_args()
    symbolicate_crash_cmd(args)

